import Alert from '../types/Alert'
import BooleanStatement from '../types/BooleanStatement'
import Course from '../types/Course'
import CourseID from '../types/CourseID'
import GlobalData from '../types/GlobalData'
import Grade from '../types/Grade'
import GraduationOption from '../types/GraduationOption'
import StateTuple from '../types/StateTuple'
import {
  booleanStatementToString,
  mapBooleanStatement,
  resolveBooleanStatement,
} from './booleanStatement'
import { hasOwnProperty } from './hasOwnProperty'

export function computeCourseRequirementErrors([data, setData]: StateTuple<GlobalData>): void {
  const prerequisiteErrors: Alert[] = []
  for (const [index, selection] of data.courseSelections.entries()) {
    const course = getCourse(data, selection.courseId)
    if (!arePrerequisitesMet(data, course, selection.grade))
      prerequisiteErrors.push({
        id: index,
        message: `${course.name}: ${course.prerequisitesText}`,
        ignored: false,
      })
    // deal with corequisites
  }

  const newData = { ...data, courseRequirementErrors: prerequisiteErrors }
  setData(newData)
}

export function computeGraduationRequirementErrors([data, setData]: StateTuple<GlobalData>): void {
  const gradRequirementErrors: Omit<Alert, 'id'>[] = []
  for (const selectionId of data.graduationOptionSelections) {
    const gradOption = getGradOption(data, selectionId)
    const graduationCreditErrors = getGraduationCreditErrors(data, gradOption)
    const graduationCourseErrors = getGraduationCourseErrors(data, gradOption)
    gradRequirementErrors.push(...graduationCreditErrors, ...graduationCourseErrors)
  }

  // assign IDs to these errors
  const gradRequirementAlerts: Alert[] = gradRequirementErrors.map((err, index) => ({
    ...err,
    id: index,
  }))

  const newData = { ...data, courseRequirementErrors: gradRequirementAlerts }
  setData(newData)
}

function arePrerequisitesMet(data: GlobalData, course: Course, grade: Grade): boolean {
  if (course.prerequisites === undefined) return true

  return resolveBooleanStatement(
    mapBooleanStatement(course.prerequisites, (courseId) => {
      // Among course selections in grades before this course is being taken,
      // is there an instance of this particular prerequisite?
      return (
        data.courseSelections
          .filter((s) => s.grade < grade)
          .find((s) => s.courseId === courseId) !== undefined
      )
    }),
  )
}

function getGraduationCourseErrors(
  data: GlobalData,
  gradOption: GraduationOption,
): Omit<Alert, 'id'>[] {
  const courseReqs = gradOption.courseRequirements
  if (courseReqs === undefined) return []

  // split BS at top level and clause, if any
  // evaluate each resulting BS
  // if any fails, return a partial Alert with message generated by bsToString
  let independentRequirements: BooleanStatement<CourseID>[]
  if (hasOwnProperty(courseReqs, 'all'))
    // Split up top-level 'all' because each su
    independentRequirements = (courseReqs.all as BooleanStatement<CourseID>[])
  
  if (hasOwnProperty(courseReqs, 'any') || hasOwnProperty(courseReqs, 'none')) 
    independentRequirements = [courseReqs]
}

function getCourse(data: GlobalData, courseId: CourseID): Course {
  return data.courses.find((c) => c.id === courseId) as Course
}
